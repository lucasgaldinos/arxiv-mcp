{
	"version": "2.0.0",
	"tasks": [
		{
			"label": "Test: Run All Tests",
			"type": "shell",
			"command": "python",
			"args": ["-m", "pytest", "tests/", "-v", "--tb=short"],
			"group": "test",
			"presentation": {
				"echo": true,
				"reveal": "always",
				"focus": false,
				"panel": "shared",
				"showReuseMessage": true,
				"clear": false
			},
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Test: Run with Coverage",
			"type": "shell",
			"command": "python",
			"args": ["-m", "coverage", "run", "-m", "pytest", "tests/", "-v"],
			"group": "test",
			"presentation": {
				"echo": true,
				"reveal": "always",
				"focus": false,
				"panel": "shared"
			},
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Test: Coverage Report",
			"type": "shell",
			"command": "python",
			"args": ["-m", "coverage", "report", "--show-missing"],
			"group": "test",
			"dependsOn": "Test: Run with Coverage"
		},
		{
			"label": "Test: Coverage HTML Report",
			"type": "shell",
			"command": "python",
			"args": ["-m", "coverage", "html"],
			"group": "test",
			"dependsOn": "Test: Run with Coverage"
		},
		{
			"label": "Test: Run Unit Tests",
			"type": "shell",
			"command": "python",
			"args": ["-m", "pytest", "tests/", "-v", "-m", "unit"],
			"group": "test",
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Test: Run Integration Tests",
			"type": "shell",
			"command": "python",
			"args": ["-m", "pytest", "tests/", "-v", "-m", "integration"],
			"group": "test",
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Test: Run Parallel Tests",
			"type": "shell",
			"command": "python",
			"args": ["-m", "pytest", "tests/", "-v", "-n", "auto"],
			"group": "test",
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Test: Quick Smoke Tests",
			"type": "shell",
			"command": "python",
			"args": ["-m", "pytest", "tests/", "-v", "-m", "smoke", "--maxfail=1"],
			"group": "test",
			"options": {
				"env": {
					"PYTHONPATH": "${workspaceFolder}/src"
				}
			}
		},
		{
			"label": "Quality: Lint All",
			"type": "shell",
			"command": "python",
			"args": ["-m", "flake8", "src/", "tests/"],
			"group": "build",
			"presentation": {
				"echo": true,
				"reveal": "always",
				"focus": false,
				"panel": "shared"
			}
		},
		{
			"label": "Quality: Type Check",
			"type": "shell",
			"command": "python",
			"args": ["-m", "mypy", "src/arxiv_mcp"],
			"group": "build"
		},
		{
			"label": "Quality: Format Code",
			"type": "shell",
			"command": "python",
			"args": ["-m", "black", "src/", "tests/"],
			"group": "build"
		},
		{
			"label": "Automated Docstring Generation",
			"type": "shell",
			"command": "python",
			"args": [
				"-c",
				"import ast\nimport os\nimport sys\n\ndef find_missing_docstrings(file_path):\n    \"\"\"Find functions and classes missing docstrings.\"\"\"\n    with open(file_path, 'r', encoding='utf-8') as f:\n        try:\n            tree = ast.parse(f.read())\n        except SyntaxError:\n            return []\n    \n    missing = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):\n            # Check if first statement is a docstring\n            if (not node.body or\n                not isinstance(node.body[0], ast.Expr) or\n                not isinstance(node.body[0].value, ast.Constant) or\n                not isinstance(node.body[0].value.value, str)):\n                missing.append({\n                    'type': type(node).__name__,\n                    'name': node.name,\n                    'line': node.lineno,\n                    'file': file_path\n                })\n    return missing\n\ndef scan_project():\n    \"\"\"Scan entire project for missing docstrings.\"\"\"\n    python_files = []\n    for root, dirs, files in os.walk('src'):\n        for file in files:\n            if file.endswith('.py'):\n                python_files.append(os.path.join(root, file))\n    \n    all_missing = []\n    for file_path in python_files:\n        missing = find_missing_docstrings(file_path)\n        all_missing.extend(missing)\n    \n    print(f'Found {len(all_missing)} missing docstrings across {len(python_files)} Python files:')\n    \n    # Group by file\n    by_file = {}\n    for item in all_missing:\n        file = item['file']\n        if file not in by_file:\n            by_file[file] = []\n        by_file[file].append(item)\n    \n    for file, items in sorted(by_file.items()):\n        print(f'\\n{file}: {len(items)} missing')\n        for item in items:\n            print(f'  Line {item[\"line\"]}: {item[\"type\"]} {item[\"name\"]}')\n    \n    return all_missing\n\nif __name__ == '__main__':\n    missing = scan_project()\n    print(f'\\nTotal missing docstrings: {len(missing)}')\n"
			],
			"isBackground": false,
			"group": "build"
		}
	]
}